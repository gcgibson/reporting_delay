mean(rgamma(1000,shape=1,scale=1))
mean(rgamma(1000,shape=1,scale=1))
mean(2*rgamma(1000,shape=1,scale=1))
mean(rgamma(1000,shape=1,scale=1/2))
mean(rgamma(1000,shape=1,scale=1/2))
mean(rgamma(1000,shape=1,scale=2))
mean(rgamma(1000,shape=1,scale=2))
mean(rgamma(1000,shape=1,scale=2))
mean(rgamma(1000,shape=1,scale=2))
mean(rgamma(1000,shape=1,rate=2))
mean(rgamma(1000,shape=1,rate=/5))
mean(rgamma(1000,shape=1,rate=.5))
?plot
allshootings$number_of_victims
allshootings$number_of_victims = allshootings$number_of_victims[(allshootings$number_of_victims != 0).any()]
number_of_victims
greater_than_0 <- c()
greater_than_0
number_of_victims
greater_than_0 <- c()
for (i in 1:length(number_of_victims)){
if (number_of_victims[i] > 0){
greater_than_0 <- c(greater_than_0, number_of_victims[i])
}
}
greater_than_0
hist(greater_than_0,main="Historgram of Number of Victims | Number of Victims > 0")
hist(greater_than_0,main="Historgram of Number of Victims | Number of Victims > 0")
greater_than_0 <- c()
for (i in 1:length(number_of_victims)){
if (number_of_victims[i] > 1){
greater_than_0 <- c(greater_than_0, number_of_victims[i])
}
}
hist(greater_than_0,main="Historgram of Number of Victims | Number of Victims > 1")
greater_than_0
greater_than_0 <- c()
for (i in 1:length(number_of_victims)){
if (number_of_victims[i] > 0){
greater_than_0 <- c(greater_than_0, number_of_victims[i])
}
}
hist(greater_than_0,main="Historgram of Number of Victims | Number of Victims > 0")
?hist
reportingTriangle(nc)
source('~/Downloads/biom12194-sm-0001-suppdatacode/R/brg.R', echo=TRUE)
#Load surveillance package. The nowcast functionality is available
#from version 1.8-0. Currently, this version is not on CRAN but only
#on R-forge -- see http://surveillance.r-forge.r-project.org for
#details on how to install this version.
library("surveillance")
#Source in extra code. This will go into the surveillance package
#in the future. Currently the functions are somewhat specific
#to the STEC O104:H4 application.
source("../R/animate-nowcast.R")
source("../R/plotPMF.R")
source("../R/plotMedianDelay.R")
source("../R/plotReportingTriangle.R")
#Load the data, which are courtesy of the Robert Koch Institute,
#Berlin, Germany.
#
#Note: The data are such that the resulting reporting triangle
#corresponds to Fig.1 of the Web appendix. This means that the reports
#which arrived with a delay longer than 15 days are set to have have
#arrived after 15 days. Altogether, this gives small discrepancies
#with the results in the manuscript. However, as mentioned in the paper,
#longer delays were not very relevant for the nowcasting.
######################################################################
data("husO104Hosp")
######################################################################
#Set some variables for the processing
######################################################################
options(color=TRUE) #Say output of figures can be in color (b/w for paper)
source('~/Downloads/biom12194-sm-0001-suppdatacode/R/brg.R', echo=TRUE)
reportingTriangle(nc)
View(reportingTriangle(nc))
typeof(reportingTriangle(nc))
typeof(reportingTriangle(nc))
write.csv(reportingTriangle(nc),"nc.csv")
?qnorm
library(forecast)
?arima.sim
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
?write.csv
typeof(simData)
attributed(simData)
attributes(simData)
source('~/BayesProject/blrp.R', echo=TRUE)
meningo
attributes(meningo)
attr(meningo,"observed")
influMen
# convert to sts class and extract meningococcal disease time series
salmonella <- read.table(system.file("extdata/salmonella.agona.txt",
package = "surveillance"), header = TRUE)
# look at data.frame
str(salmonella)
salmonellaDisProg <- create.disProg(week = 1:nrow(salmonella),
observed = salmonella$observed,
state = salmonella$state,
start = c(1990, 1))
# look at disProg object
salmonellaDisProg
salmonellaDisProg
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
salmonella
source('~/BayesProject/blrp.R', echo=TRUE)
simData
attr(simData,"observed")
source('~/BayesProject/blrp.R', echo=TRUE)
simData
attr(simData, observed)
attr(simData, "observed")
source('~/BayesProject/blrp.R', echo=TRUE)
attr(simData, "observed")
attr(simData, "observed")
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
?simulate
source('~/BayesProject/blrp.R', echo=TRUE)
simData
attr(simData,"observed")
attr(simData, "observed")
source('~/BayesProject/blrp.R', echo=TRUE)
attr(simData, "observed")
?simulate
source('~/BayesProject/blrp.R', echo=TRUE)
simData
simData[,,"observed"]
simData["observed"]
simData[,"observed"]
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/BayesProject/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
source('~/Desktop/blrp.R', echo=TRUE)
install.packages("dengueThailand")
debugSource('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
bayes_hohle_offset_2
truth
mse_vec
bayes_hohle_offset_2
mse_vec
bayes_hohle_offset_2
bayes_hohle_offset_2
bayes_hohle_offset_2
mse_vec
bayes_hohle_offset_2
mse_vec
bayes_hohle_offset_2
bayes_hohle_offset_2
bayes_hohle_offset_2
mse_vec
delay_model_estimate
bayes_hohle_offset_2
bayes_hohle_offset_2
delay_model_estimate
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
View(mse_vec)
debugSource('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
debugSource('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
bayes_hohle_offset_2
truth
bayes_hohle_offset_2
bayes_hohle_offset_2
v
bayes_hohle_offset_2
bayes_hohle_offset_2
delay_model_estimate
truth
mean((rowMeans(delay_model_estimate)-truth)^2)
mean((rowMeans(bayes_hohle_offset_2)-truth)^2)
bayes_hohle_offset_2
bayes_hohle_offset_2[1] <- 9
bayes_hohle_offset_2[1] <- 0
mean((rowMeans(bayes_hohle_offset_2)-truth)^2)
mean((rowMeans(bayes_hohle_offset_2)-truth)^2) > mean((rowMeans(delay_model_estimate)-truth)^2)
mean((rowMeans(bayes_hohle_offset_2)-truth)^2) <
mean((rowMeans(delay_model_estimate)-truth)^2)
mean((rowMeans(delay_model_estimate)-truth)^2)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
colMeans(mse_vec)
mse_vec
debugSource('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
bayes_hohle_offset_2
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
View(mse_vec)
colMeans(mse_vec)
colMeans(mse_vec)/1000
colMeans(coverage_prob)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
colMeans(coverage_prob)
colMeans(mse_vec)/1000
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
View(mse_vec)
colMeans(mse_vec)/1000
colMeans(mse_vec[1:10,])/1000
colMeans(mse_vec[1:9,])/1000
colMeans(coverage_prob[1:9,])
?sample
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
library(MHadaptive)
library(MCMCpack)
library(forecast)
library(matrixStats)
library(MASS)
library(boot)
setwd("/Users/gcgibson/reporting_delay/")
source('utils.R')
source('delay_model.R')
source('zero_model.R')
source('bayes_model.R')
source('bayes_model_descending_variance.R')
## read in data
reporting_triangle <- read.csv("chiang_mai_10.csv",header = FALSE)
## SET GLOBAL DELAY
D <- 10
### CV START /STOP
start <- 40
stop <-  dim(reporting_triangle)[1]
NSIM <- 10
### INITIALIZE EMPTY VECS
mse_vec <- matrix(NA,nrow=stop-start + 1,ncol=5)
coverage_prob <- matrix(NA,nrow=stop-start + 1,ncol=5)
###  cv cutoffs
for (cv_cutoff in start:stop){
print (cv_cutoff)
test_reporting_triangle <- reporting_triangle[1:cv_cutoff,]
## GET PARTIALLY OBSERVED
po_data <- get_po_data(test_reporting_triangle,D,cv_cutoff)
### MODEL ESTIMATES
delay_model_estimate <- get_delay_model(test_reporting_triangle,po_data,D,NSIM)
#zero_inf_offset_2 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,2)
bayes_hohle_offset_2 <- get_bayes_model_descending_var(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate)
#zero_inf_offset_5 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,5)
#bayes_hohle_offset_5 <- get_bayes_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate,5)
### COMPUTE MSE
truth <- rowSums(test_reporting_triangle)[(cv_cutoff-D +1):cv_cutoff]
mse_vec[(cv_cutoff-start +1),1] <- mean((rowMeans(delay_model_estimate)-truth)^2)
#mse_vec[(cv_cutoff-start +1),2] <- mean((rowMeans(zero_inf_offset_2)-truth)^2)
mse_vec[(cv_cutoff-start +1),3] <- mean((rowMeans(bayes_hohle_offset_2)-truth)^2)
#mse_vec[(cv_cutoff-start +1),4] <- mean((rowMeans(zero_inf_offset_5)-truth)^2)
#mse_vec[(cv_cutoff-start +1),5] <- mean((rowMeans(bayes_hohle_offset_5)-truth)^2)
#png(paste('fcast',toString(cv_cutoff),'.png',sep=""))
#plot((cv_cutoff-D+1):cv_cutoff,truth,col="black",type="l",ylim =c(0,10000))
# lines((cv_cutoff-D+1):cv_cutoff,rowMeans(zero_inf),col="blue")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(bayes_hohle),col="orange")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(delay_model_estimate),type="l",col="red")
#legend("topleft",legend=c("Truth", "Zero","Bayes","Delay"),
#       col=c("black","blue", "orange","red"), lty=1:2, cex=0.8)
# dev.off()
### Coverage Probability
quant_delay <-rowQuantiles(delay_model_estimate,probs = c(.025,.975))
delay_cp <- 0
for (cp_iter in 1:D){
if (quant_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=quant_delay[cp_iter,2]){
delay_cp <- delay_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),1] <- delay_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_2,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),2] <- zero_inf_cp/D
bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_2,probs = c(.025,.975))
bayes_hohle_cp <- 0
for (cp_iter in 1:D){
if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
bayes_hohle_cp <- bayes_hohle_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),3] <- bayes_hohle_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_5,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),4] <- zero_inf_cp/D
#
# bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_5,probs = c(.025,.975))
# bayes_hohle_cp <- 0
# for (cp_iter in 1:D){
#   if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
#     bayes_hohle_cp <- bayes_hohle_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),5] <- bayes_hohle_cp/D
#
}
bayes_estimate_trunc
dim(bayes_estimate_trunc)
shape(bayes_estimate_trunc)
length(bayes_estimate_trunc)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
library(MHadaptive)
library(MCMCpack)
library(forecast)
library(matrixStats)
library(MASS)
library(boot)
setwd("/Users/gcgibson/reporting_delay/")
source('utils.R')
source('delay_model.R')
source('zero_model.R')
source('bayes_model.R')
source('bayes_model_descending_variance.R')
## read in data
reporting_triangle <- read.csv("chiang_mai_10.csv",header = FALSE)
## SET GLOBAL DELAY
D <- 10
### CV START /STOP
start <- 40
stop <-  dim(reporting_triangle)[1]
NSIM <- 10
### INITIALIZE EMPTY VECS
mse_vec <- matrix(NA,nrow=stop-start + 1,ncol=5)
coverage_prob <- matrix(NA,nrow=stop-start + 1,ncol=5)
###  cv cutoffs
for (cv_cutoff in start:stop){
print (cv_cutoff)
test_reporting_triangle <- reporting_triangle[1:cv_cutoff,]
## GET PARTIALLY OBSERVED
po_data <- get_po_data(test_reporting_triangle,D,cv_cutoff)
### MODEL ESTIMATES
delay_model_estimate <- get_delay_model(test_reporting_triangle,po_data,D,NSIM)
#zero_inf_offset_2 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,2)
bayes_hohle_offset_2 <- get_bayes_model_descending_var(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate)
#zero_inf_offset_5 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,5)
#bayes_hohle_offset_5 <- get_bayes_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate,5)
### COMPUTE MSE
truth <- rowSums(test_reporting_triangle)[(cv_cutoff-D +1):cv_cutoff]
mse_vec[(cv_cutoff-start +1),1] <- mean((rowMeans(delay_model_estimate)-truth)^2)
#mse_vec[(cv_cutoff-start +1),2] <- mean((rowMeans(zero_inf_offset_2)-truth)^2)
mse_vec[(cv_cutoff-start +1),3] <- mean((rowMeans(bayes_hohle_offset_2)-truth)^2)
#mse_vec[(cv_cutoff-start +1),4] <- mean((rowMeans(zero_inf_offset_5)-truth)^2)
#mse_vec[(cv_cutoff-start +1),5] <- mean((rowMeans(bayes_hohle_offset_5)-truth)^2)
#png(paste('fcast',toString(cv_cutoff),'.png',sep=""))
#plot((cv_cutoff-D+1):cv_cutoff,truth,col="black",type="l",ylim =c(0,10000))
# lines((cv_cutoff-D+1):cv_cutoff,rowMeans(zero_inf),col="blue")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(bayes_hohle),col="orange")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(delay_model_estimate),type="l",col="red")
#legend("topleft",legend=c("Truth", "Zero","Bayes","Delay"),
#       col=c("black","blue", "orange","red"), lty=1:2, cex=0.8)
# dev.off()
### Coverage Probability
quant_delay <-rowQuantiles(delay_model_estimate,probs = c(.025,.975))
delay_cp <- 0
for (cp_iter in 1:D){
if (quant_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=quant_delay[cp_iter,2]){
delay_cp <- delay_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),1] <- delay_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_2,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),2] <- zero_inf_cp/D
bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_2,probs = c(.025,.975))
bayes_hohle_cp <- 0
for (cp_iter in 1:D){
if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
bayes_hohle_cp <- bayes_hohle_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),3] <- bayes_hohle_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_5,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),4] <- zero_inf_cp/D
#
# bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_5,probs = c(.025,.975))
# bayes_hohle_cp <- 0
# for (cp_iter in 1:D){
#   if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
#     bayes_hohle_cp <- bayes_hohle_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),5] <- bayes_hohle_cp/D
#
}
bayes_estimate_trunc
dim(bayes_estimate_trunc)
source('~/reporting_delay/reporting_delay_no_bayes.R', echo=TRUE)
View(coverage_prob)
library(MHadaptive)
library(MCMCpack)
library(forecast)
library(matrixStats)
library(MASS)
library(boot)
setwd("/Users/gcgibson/reporting_delay/")
source('utils.R')
source('delay_model.R')
source('zero_model.R')
source('bayes_model.R')
source('bayes_model_descending_variance.R')
## read in data
reporting_triangle <- read.csv("chiang_mai_10.csv",header = FALSE)
## SET GLOBAL DELAY
D <- 10
### CV START /STOP
start <- 40
stop <-  dim(reporting_triangle)[1]
NSIM <- 10
### INITIALIZE EMPTY VECS
mse_vec <- matrix(NA,nrow=stop-start + 1,ncol=5)
coverage_prob <- matrix(NA,nrow=stop-start + 1,ncol=5)
###  cv cutoffs
for (cv_cutoff in start:stop){
print (cv_cutoff)
test_reporting_triangle <- reporting_triangle[1:cv_cutoff,]
## GET PARTIALLY OBSERVED
po_data <- get_po_data(test_reporting_triangle,D,cv_cutoff)
### MODEL ESTIMATES
delay_model_estimate <- get_delay_model(test_reporting_triangle,po_data,D,NSIM)
#zero_inf_offset_2 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,2)
bayes_hohle_offset_2 <- get_bayes_model_descending_var(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate)
#zero_inf_offset_5 <- get_zero_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,5)
#bayes_hohle_offset_5 <- get_bayes_model(test_reporting_triangle,po_data,D,cv_cutoff,NSIM,delay_model_estimate,5)
### COMPUTE MSE
truth <- rowSums(test_reporting_triangle)[(cv_cutoff-D +1):cv_cutoff]
mse_vec[(cv_cutoff-start +1),1] <- mean((rowMeans(delay_model_estimate)-truth)^2)
#mse_vec[(cv_cutoff-start +1),2] <- mean((rowMeans(zero_inf_offset_2)-truth)^2)
mse_vec[(cv_cutoff-start +1),3] <- mean((rowMeans(bayes_hohle_offset_2)-truth)^2)
#mse_vec[(cv_cutoff-start +1),4] <- mean((rowMeans(zero_inf_offset_5)-truth)^2)
#mse_vec[(cv_cutoff-start +1),5] <- mean((rowMeans(bayes_hohle_offset_5)-truth)^2)
#png(paste('fcast',toString(cv_cutoff),'.png',sep=""))
#plot((cv_cutoff-D+1):cv_cutoff,truth,col="black",type="l",ylim =c(0,10000))
# lines((cv_cutoff-D+1):cv_cutoff,rowMeans(zero_inf),col="blue")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(bayes_hohle),col="orange")
#lines((cv_cutoff-D+1):cv_cutoff,rowMeans(delay_model_estimate),type="l",col="red")
#legend("topleft",legend=c("Truth", "Zero","Bayes","Delay"),
#       col=c("black","blue", "orange","red"), lty=1:2, cex=0.8)
# dev.off()
### Coverage Probability
quant_delay <-rowQuantiles(delay_model_estimate,probs = c(.025,.975))
delay_cp <- 0
for (cp_iter in 1:D){
if (quant_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=quant_delay[cp_iter,2]){
delay_cp <- delay_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),1] <- delay_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_2,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),2] <- zero_inf_cp/D
bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_2,probs = c(.025,.975))
bayes_hohle_cp <- 0
for (cp_iter in 1:D){
if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
bayes_hohle_cp <- bayes_hohle_cp + 1
}
}
coverage_prob[(cv_cutoff-start +1),3] <- bayes_hohle_cp/D
# zero_inf_delay <-rowQuantiles(zero_inf_offset_5,probs = c(.025,.975))
# zero_inf_cp <- 0
# for (cp_iter in 1:D){
#   if (zero_inf_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=zero_inf_delay[cp_iter,2]){
#     zero_inf_cp <- zero_inf_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),4] <- zero_inf_cp/D
#
# bayes_hohle_delay <-rowQuantiles(bayes_hohle_offset_5,probs = c(.025,.975))
# bayes_hohle_cp <- 0
# for (cp_iter in 1:D){
#   if (bayes_hohle_delay[cp_iter,1] <= truth[cp_iter] & truth[cp_iter] <=bayes_hohle_delay[cp_iter,2]){
#     bayes_hohle_cp <- bayes_hohle_cp + 1
#   }
# }
# coverage_prob[(cv_cutoff-start +1),5] <- bayes_hohle_cp/D
#
}
